
real t=0; /*time parameter*/

int it =1; /*number of timestep*/

int[int] order = [1,1,1]; /*order*/


real[int] elsize(Th.nt);



for(int el=0; el<Th.nt; el++)
{
    elsize[el]=Th[el].area;
}

real maxElSize=1/elsize.max;

for (int el=0; el<Th.nt; el++)
{
    elsize[el]=elsize[el]*maxElSize;
}

h0size[]=elsize; /*form P0 field from vector, containing size of the element*/

hsize=h0size;

cout<<"Max Element Size =============== "<<hsize[].max<<endl;
cout<<"Min Element Size =============== "<<hsize[].min<<endl;




//plot(p, wait=1, value=1, cmm="Pressure0");

//plot(phi, wait=1, value=1, cmm="Porosity0");

//plot(Sw, wait=1, value=1, cmm="Saturation0");

savevtk("./num/sol0.vtu",Th, p,SwOld,phi,dataname="p Sw phi", order=order);

while (t < tMax){


    cout << "it = " <<it<<"\t;t="<< t << endl;

    
    
    real relSwError = 1.0;

    

    int kIter =0;

    int cycle=0;

    while (relSwError>1e-7){

        load "MUMPS_seq"

        //load "UMFPACK64"
        /*solving DIFFUSION problem*/
        real relPhiError= 1.0;

        while (relPhiError>1e-7)
        {

        

            matrix Ad=DiffusionBiLinear(Vh,Vh);

            real[int] RHSd=DiffusionLinear(0,Vh);

            set(Ad, solver=sparsesolver);

            cout<<"Pressure Matrix Formed"<<endl;

            cpu=clock();
            p[]=Ad^-1*RHSd;
            cout<<"Pressure solution time: "<<clock()-cpu<<endl;

            phi=phi0+cr*phi0*(p-pOld);

            relPhiError=
            int2d(Th)(abs(phi-phiIter)) / int2d(Th)(abs(phi));

            

            cout<<"relPhiError = "<<relPhiError<<endl;

        
            //plot(phi, fill=1, value=1, dim=3, wait=1);
                
            phiIter=phi;

        }
        //plot(p, wait=1, value=1, fill=1, cmm="Pressure");

       vnorm=K*lambdaT(SwIter)*sqrt(grad(p)'*grad(p));

       vnorm=vnorm/vnorm[].max;


       //plot(vnorm, wait=1,fill=1, value=1, dim=3, cmm="vnorm");

       multeps=epsilon*vnorm*hsize;

       //plot(multeps, dim=3, value=1, wait=1, fill=1);

       

        /*solving TRANSPORT problem*/

        

        matrix A;

        matrix At;
        
        

        real[int] RHSt(Vh.ndof);

        real[int] RHS(Vh.ndof);

        if (PointInj){

            At=TransportBiLinearPoint(Vh,Vh);

            RHSt=TransportLinearPoint(0,Vh);

            /*penalty method for TRANSPORT*/
        

        
            cpu=clock();
            A=At+PP; /*system matrix correction with penalty term*/
            cout<<"Matrix sum time: "<<clock()-cpu<<endl;

            RHS=RHSt+d; /*RHS correction with penalty term*/
        }
        else{

            cpu=clock();
            mult1=K*lambdaT(SwIter)*fW(SwIter);

            mult2=K*lambdaT(SwIter)*fWCoreyDerivative(SwIter);
            
            A=TransportBiLinear(Vh1,Vh1);
       
            cout<<"Transport Matrix gen time: "<<clock()-cpu<<endl;
            cpu=clock();
            RHS=TransportLinear(0,Vh1);
            cout<<"Transport RHS gen time: "<<clock()-cpu<<endl;

        }


        set(A,solver=sparsesolver);
        //set(A,solver=UMFPACK);
        
        cpu=clock();
        Sw[]=A^-1*RHS;
        cout<<"Transport solver time: "<<clock()-cpu<<endl;
        
        
        

        
        
        relSwError=
        int2d(Th)(abs(Sw-SwIter)) / int2d(Th)(abs(Sw));

        cout<<"["<<kIter<<"]: relSwError = "<<relSwError<<endl;

        //plot(Sw, wait=1, value=1, fill=1, cmm="Saturation");

        SwIter = Sw;


        

        //pOld=pIter;


        

        kIter++;

        if (kIter>50)
        {
            dt=dt/2;

            kIter=0;

            epsilon=epsilon;

            cycle++;
            
        }       

    }
if (cycle>0)
 {dt=dt*cycle*2;}  

    plot(Sw, wait=0, value=1, fill=1, cmm="Saturation");

    savevtk("./num/sol"+it+".vtu",Th, p,Sw,phi,dataname="p Sw phi", order=order);




/*Update at the end of timestep*/

/*solving POROSITY*/

        
//pIter=p;

//phi=phiOld+cr*phiOld*(p-pOld);

        
//plot(phi, fill=1, value=1, dim=3, wait=1);
    
//phiIter=phi;

SwOld = Sw;
p=pOld;

phi=phiOld;
       
cout<<"time = "<<t/3600<<endl;

t=t+dt;
it++;

}